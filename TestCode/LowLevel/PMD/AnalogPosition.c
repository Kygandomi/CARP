//   Example of simple analog position controller.
//  
//   There are Anlaog feedback axes that have a simple proportion controller.  The output of the controller is 
//   a voltage command for the Atlas drive (32,767 = 100% bus voltage)
//   AnalogInput1 -> Axis1
//   AnalogInput3 -> Axis3
//   AnalogInput4 -> Axis4
//   A DC Brushed Alas drive powers the actuator.  Every Axis with this configuration should have a DC Brushed Atlas attached.
//   There is no trajecory generation being used on these axes.  However, the SetPosition command can be used.  Where the positional units
//    are ADC counts.  No UPDATE command is neccesary.
//
//   There is one axis that is oscillating at ~120Hz.  Breakpoints are used to immediately reverse direction once the destination position 
//   has been reached. This is running in the normal operational mode with a position loop and trajectory generation.  Note that the velocity
//   and destination positions must be properly selected to obtain a specific frequency.
//
//    There is also a trace of the commanded position of the oscillating axis which is run.  Use the LOAD button in the Pro-Motion SCOPE
//    to see the data. Change the SCOPE's "Time Axis" to "Milliseconds".  This is useful for verifying the frequecy is correct.
//
//     Pro-Motion Usage:  Disable Status Polling in the VIEW menu.  There is not enought band width for this and it may delay the 
//     loops in this code enough to cause them to stop.  Likewise do not start a trace with Pro-Moiton. This code will start the    
//     trace instead
//       


#include "c-motion.h"
#include "PMDperiph.h"
#include "PMDsys.h"
#include "PMDdiag.h"
#include "PMDutil.h"

#define MAJOR_VERSION 1
#define MINOR_VERSION 0


USER_CODE_VERSION(MAJOR_VERSION,MINOR_VERSION);

PMDresult RunController(PMDAxisHandle* pAxis,int tolerance, PMDPeriphHandle* phPeriphIO, PMDuint32 AnalogChannel);
void StartOscillateLoop(PMDAxisHandle* pAxis);
void ServiceOscillateLoop(PMDAxisHandle* pAxis);	
void ConfigureAnalogFeedbackAxis(PMDAxisHandle* pAxis);
void SetupMyTrace(PMDAxisHandle* phAxis, PMDuint32 bufferlength);

  // in Pro-MotionExport.c
void SetupAxis1(PMDAxisHandle* phAxis1);
void SetupAxis2(PMDAxisHandle* phAxis1);
void SetupAxis3(PMDAxisHandle* phAxis1);
void SetupAxis4(PMDAxisHandle* phAxis1);

PMDint32 oscpos1,oscpos2,oscvel;
int oscstate;

USER_CODE_TASK( AnalogPosition )
{
    PMDDeviceHandle *phDevice = NULL;
	PMDAxisHandle hAxis1;
	PMDAxisHandle hAxis2;
	PMDAxisHandle hAxis3;
	PMDAxisHandle hAxis4;
	PMDPeriphHandle hPeriphIO;
	PMDDataSize datasize = PMDDataSize_16Bit;
	PMDresult result = 0;
 

    PMDprintf("Running Analog Position Example\r\n");

    PMD_ABORTONERROR(PMDAxisOpen(&hAxis1, phDevice, PMDAxis1 ))   
	PMD_ABORTONERROR(PMDAxisOpen(&hAxis2, phDevice, PMDAxis2 ))
	PMD_ABORTONERROR(PMDAxisOpen(&hAxis3, phDevice, PMDAxis3 ))
	PMD_ABORTONERROR(PMDAxisOpen(&hAxis4, phDevice, PMDAxis4 ))
	
	// open a Peripheral IO handle to addresses 0 and above
	PMD_ABORTONERROR(PMDPeriphOpenPIO(&hPeriphIO, phDevice, 0, 0, datasize));

	ConfigureAnalogFeedbackAxis(&hAxis1);
//	ConfigureAnalogFeedbackAxis(&hAxis3);
//	ConfigureAnalogFeedbackAxis(&hAxis4);
	
	oscpos1=0;
	oscpos2=2000;
	oscvel=10000000;
		
	// This is a fucntion in the file automatically generated by Pro-Motion.
	SetupAxis2(&hAxis2);
	
	SetupMyTrace(&hAxis2,2000);
	
	StartOscillateLoop(&hAxis2);
	
	//Axis2 should be moving now so start tracing of its Commanded Position.  Use the LOAD button in the Pro-Motion Scope to see the
	//results of this trace
	PMDSetTraceStart( &hAxis2, PMDAxis2, PMDTraceConditionImmediate, 0,0 );
	
	
	for(;;)
	{

	    RunController(&hAxis1,100,&hPeriphIO,PMDMachineIO_AICh1);
	//	RunController(&hAxis3,100,&hPeriphIO,PMDMachineIO_AICh3);
	//	RunController(&hAxis4,100,&hPeriphIO,PMDMachineIO_AICh4);
		ServiceOscillateLoop(&hAxis2);	
	 
	}
	
}



void ServiceOscillateLoop(PMDAxisHandle* pAxis)	
{
	PMDuint16 status;
	PMDGetEventStatus(pAxis, &status);
	if(status&0x0001)
	{
	    PMDResetEventStatus(pAxis,0);  // Reset all pending Events
		
		// Rearm breakpoint
		PMDSetBreakpoint(pAxis,PMDBreakpoint1,PMDAxis2,PMDBreakpointActionUpdate,PMDBreakpointEventStatus);
		if(oscstate)
        {
			PMDSetPosition(pAxis,oscpos1);
		    oscstate=0;
		}	
		else
		{
			PMDSetPosition(pAxis,oscpos2);
			oscstate=1;
		}	
	}
	
	return;
	
}



PMDresult RunController(PMDAxisHandle* pAxis,int tolerance, PMDPeriphHandle* phPeriphIO, PMDuint32 AnalogChannel)
{
    PMDint32 destination;
	PMDint16 actposition; //,command;
	int error,Kp,done,command;
	PMDresult result;
	Kp=40;
	PMDGetPosition(pAxis,&destination);
	
	//Read Analog position
	PMD_ABORTONERROR(PMDPeriphRead(phPeriphIO, &actposition, AnalogChannel, 1));
	
	error=destination-actposition;
	command=error*Kp;
//	PMDprintf("act=%d  error=%d   tol=%d\n",actposition,error,tolerance);
	if(error<0) error*=-1;
	if(error<tolerance)
	{
		PMDSetMotorCommand(pAxis,0);
		PMDUpdate(pAxis);
		done=0;
	}	
	else
    {	
		if(command>30000) command=30000;
		if(command<-30000) command=-30000;
		PMDSetMotorCommand(pAxis,command);
		PMDUpdate(pAxis);
	}
	
  // PMDprintf("mtrcmd= %d\n",command);
	
	return 0;
}
	
void ConfigureAnalogFeedbackAxis(PMDAxisHandle* pAxis)
{
	
	PMDprintf("Configuring Analog Feedback Axis\n");
	PMDSetMotorType(pAxis,PMDMotorTypeDCBrush);
	PMDSetOutputMode(pAxis,PMDMotorOutputAtlas);
    WaitForAtlasToConnect (pAxis);
    PMDSetOperatingMode(pAxis,0x003);  //Voltage Mode
}

void StartOscillateLoop(PMDAxisHandle* pAxis)
{
   	PMDSetBreakpointValue(pAxis,PMDBreakpoint1,0x00010001);	  // Look for bit 0 going active (Motion Complete Event Status)
	PMDSetAcceleration(pAxis,0x3FFFFFFF);
	PMDSetVelocity(pAxis,oscvel);
	PMDSetPosition(pAxis,oscpos2);
	PMDResetEventStatus(pAxis,0);  // Reset all pending Events
	PMDUpdate(pAxis);
	// Axis should now be moving
	
	PMDSetBreakpoint(pAxis,PMDBreakpoint1,PMDAxis2,PMDBreakpointActionUpdate,PMDBreakpointEventStatus);
	//The move to position oscpos2 has started so setup the move back to oscpos1.
	PMDSetPosition(pAxis,oscpos1);   
	oscstate=0;
    return;
		
}



void SetupMyTrace(PMDAxisHandle* phAxis, PMDuint32 bufferlength)
{
    PMDSetTraceStop( phAxis, 0, PMDTraceConditionImmediate, 0, PMDTraceTriggerStateHigh );
    
    // setup the trace buffer (buffer ID = 0)
    PMDSetBufferLength( phAxis, 0, bufferlength );
    PMDSetTracePeriod( phAxis, 1); // cycle(s) per trace
    PMDSetTraceMode( phAxis, PMDTraceModeOneTime );

    // single axis dynamics trace
    PMDSetTraceVariable( phAxis, PMDTraceVariable1, PMDAxis2, PMDTraceCommandedPosition );
    PMDSetTraceVariable( phAxis, PMDTraceVariable2, PMDAxis2, PMDTraceNone );
    PMDSetTraceVariable( phAxis, PMDTraceVariable3, PMDAxis2, PMDTraceNone ); 
}
